// app/api/pinata-images/route.ts
// FIXED: uses legacy pinList API for files uploaded via pinFileToIPFS,
// with a v3 fallback for files uploaded via the newer Files API.
import { NextRequest, NextResponse } from "next/server";

const PINATA_JWT = process.env.PINATA_JWT!;
const PINATA_GATEWAY = process.env.NEXT_PUBLIC_PINATA_GATEWAY ?? "https://gateway.pinata.cloud";
const PINATA_NFT_GROUP_ID = process.env.PINATA_NFT_IMAGE_GROUP_ID ?? null;

export interface PinataFile {
  id: string;
  name: string;
  cid: string;
  url: string;
  size: number;
  created_at: string;
}

// ── GET: list files ───────────────────────────────────────────────────────────
// Your existing files were uploaded via pinFileToIPFS (legacy API), so they
// only appear in /data/pinList — NOT in the v3 /files endpoint.
// We try v3 first (for future uploads), then fall back to pinList.
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const groupId = searchParams.get("groupId") ?? PINATA_NFT_GROUP_ID;

    // ── Strategy 1: v3 public files API ───────────────────────────────────
    if (groupId) {
      const v3Res = await fetch(
        `https://api.pinata.cloud/v3/files/public?group=${groupId}&limit=100&order=DESC`,
        {
          headers: { Authorization: `Bearer ${PINATA_JWT}` },
          cache: "no-store",
        }
      );

      if (v3Res.ok) {
        const v3Json = await v3Res.json();
        const v3Files: PinataFile[] = (v3Json.data?.files ?? []).map((f: any) => ({
          id: f.id,
          name: f.name ?? f.id,
          cid: f.cid,
          url: `${PINATA_GATEWAY}/ipfs/${f.cid}`,
          size: f.size ?? 0,
          created_at: f.created_at ?? "",
        }));

        if (v3Files.length > 0) {
          return NextResponse.json({ files: v3Files });
        }
        // Fall through if empty — legacy files won't show here
      }
    }

    // ── Strategy 2: Legacy pinList API ───────────────────────────────────
    // This is where pinFileToIPFS files live (Whisperain, Myrrh, gyate, etc.)
    const legacyParams = new URLSearchParams({
      status: "pinned",
      pageLimit: "100",
      pageOffset: "0",
    });

    const legacyRes = await fetch(
      `https://api.pinata.cloud/data/pinList?${legacyParams.toString()}`,
      {
        headers: { Authorization: `Bearer ${PINATA_JWT}` },
        cache: "no-store",
      }
    );

    if (!legacyRes.ok) {
      const text = await legacyRes.text();
      throw new Error(`Pinata pinList failed: ${text}`);
    }

    const legacyJson = await legacyRes.json();

    const files: PinataFile[] = (legacyJson.rows ?? [])
      .filter((row: any) => {
        // Only include image files; exclude GIFs generated by variant-image route
        const name: string = (row.metadata?.name ?? "").toLowerCase();
        const isVariant = name.includes("_variant") || name.endsWith(".gif");
        return !isVariant;
      })
      .map((row: any) => ({
        id: row.ipfs_pin_hash,
        name: row.metadata?.name ?? row.ipfs_pin_hash,
        cid: row.ipfs_pin_hash,
        url: `${PINATA_GATEWAY}/ipfs/${row.ipfs_pin_hash}`,
        size: row.size ?? 0,
        created_at: row.date_pinned ?? "",
      }));

    return NextResponse.json({ files });
  } catch (err: any) {
    console.error("[pinata-images GET]", err);
    return NextResponse.json({ error: err.message ?? "Internal error" }, { status: 500 });
  }
}

// ── POST: upload a new image ──────────────────────────────────────────────────
export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();
    const file = formData.get("file") as Blob | null;
    const name = (formData.get("name") as string | null) ?? "nft-image";
    const groupId = (formData.get("groupId") as string | null) ?? PINATA_NFT_GROUP_ID;

    if (!file) return NextResponse.json({ error: "No file provided" }, { status: 400 });

    const uploadForm = new FormData();
    uploadForm.append("file", file, name);
    uploadForm.append("pinataMetadata", JSON.stringify({ name }));
    const pinataOptions: Record<string, unknown> = { cidVersion: 1 };
    if (groupId) pinataOptions.groupId = groupId;
    uploadForm.append("pinataOptions", JSON.stringify(pinataOptions));

    const res = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
      method: "POST",
      headers: { Authorization: `Bearer ${PINATA_JWT}` },
      body: uploadForm,
    });

    if (!res.ok) throw new Error(`Pinata upload failed: ${await res.text()}`);
    const json = await res.json();
    const url = `${PINATA_GATEWAY}/ipfs/${json.IpfsHash}`;

    return NextResponse.json({ url, cid: json.IpfsHash });
  } catch (err: any) {
    console.error("[pinata-images POST]", err);
    return NextResponse.json({ error: err.message ?? "Internal error" }, { status: 500 });
  }
}